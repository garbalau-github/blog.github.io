---
title: Практичный React Query
description: Практичный взгляд на React Query и его особенности
author: Dominik Dorfmeister
authorImage: https://avatars.githubusercontent.com/u/1021430?v=4
coverImage: https://blog.logrocket.com/wp-content/uploads/2021/02/reactquery3.png
date: 'Feb 6 2023'
---

Оригинал - https://tkdodo.eu/blog/practical-react-query

Автор: https://github.com/tkdodo

Перевел: https://github.com/garbalau-github

---

## Введение

Когда GraphQL и особенно [Apollo Client](https://www.apollographql.com/docs/react/)
обрели свою популярность в 2018, ходило много слухах о том что эти технологии смогут заменить Redux,
а вопрос [Redux уже мертв?](https://dev.to/markerikson/redux---not-dead-yet-1d9k) стал крайне популярным.

Я помню то время, когда совершенно не понимал о чем все вокруг болтают. Я не мог понять, как какая-то
библиотека для запросов может заменить глобальный state manager, вроде Redux. Как они вообще связаны?

Мне казалось что GraphQL клиенты вроде Apollo, всего лишь будут запрашивать данные с сервера,
как например это делает [Axios](https://github.com/axios/axios) для REST, а тебе лишь
останеться найти способ сделать эти данные доступные в своем приложении.

Я еще никогда так не ошибался.

## Клиентское состояния vs. Серверного Состояния

По сути, Apollo не только дает разработчку возможность описать какие данные он хочет получить, и получить их,
он также добавляет уровень кэширования для этих данных.

Это означает, что ты можешь использовать один и тот же `useQuery` хук, в нескольких компонентах,
и запрос за данными произойдет лишь однократно, а на все последующие запросы, `useQery` будет
возвращать данные из кэша

Это все звучит очень знакомо для тех разработчиков и команд, кто использовал для таких целей Redux:
запросить данные и сервера и сделать их повсеместно доступными

Выходит мы всегда относились к состоянию сервера также как и к состоянию клиента. Однако, есть
все же одно отличие. Когда разговор идет о состоянии сервера (представьте список статей, которые
вам нужно запросить, или личную информацию пользователя, которую надо расположить в UI) - это
состояние не принадлежит клиенту. Его просто нет в нашем приложении на стороне клиента.
Мы его будто бы одалживаем, чтобы показать ее самую свежую версию на экране пользователя.
Именно сервер в данном случае является хранилещем данных.

Лично для меня, это открытие произвело некоторый сдвиг в моем понимании данных.

Если мы можем использовать кэш для того чтобы показывать данные которые нам не принадлежат,
не так то много и осталось действительно клиентского состояния и данных, которые также
необходимо сделать доступными для всего приложения.

Теперь я понял почему многие думают что Apollo сможет заменить Redux в множестве ситуаций.

## React Query

У меня никогда не было случая испробывать GraphQL

У нас есть работающие REST API, и у нас особо нет проблем с сверх-запросами, все работает нормально.

Видимо, недосаточно еще мы столкнулись с болевыми моментами которые толкнули бы нас на перемены,
особенно когда тебе надо перестроить не только клиент но и серверный код, что не так уж и легко.

Тем не менее, я все еще завидовал простоте того, как запросы данных работают на клиенте,
включая обработку состояний загрузки и ошибок. Если бы в React для REST API было что-то подобное...

И оно есть [React Query](https://react-query.tanstack.com/).

React Query - это библиотека созданная [Tanner Linsley](https://github.com/tannerlinsley) в конце 2019 года.
Эта библиотека взяла лучшее из Apollo и привнесла это в REST

React Query работает с любой функцией которая возвращает Promise, и использует стратегию кэширования stale-while-revalidate.

Библиотека уже пракчтически из коробки пытается держать ваши данными максимально акутальными,
и при этом показывая их пользователю так скоро, как только это становиться возможным,
делая общий опыт пользования приложением приятным и крайне быстрым.

Кроме этого, библиотека также крайне гибкая и позволяет кастомизировать свои различные настройки,
когда стандартных механизмом может не хватать.

Однако, не подумайте, эта статья не будет введением в React Query

Я считаю что их официальная документация отлично подходит для описания основых концепций.
Есть также видео [Видео](https://react-query.tanstack.com/docs/videos) с разных презентаций,
и целый курс от создателя [Фундаментальный курс](https://learn.tanstack.com/), отлично подойдет тем,
кто захочет познакомиться с библиотеккой поближе.

Я хочу больше сосредоточиться на некоторых практических советах, выходящих за рамки документации, которые могут быть полезны, когда вы уже работаете с библиотекой.

Это то, что я усвоил за последние пару месяцев, когда не только активно использовал библиотеку на работе, но и
но также принимал участие в сообществе React Query, отвечая на вопросы в Discord и в обсуждениях GitHub.

### Настройки по умолчанию

Я считаю что React Query [Настройки по умолчанию](https://react-query.tanstack.com/docs/guides/important-defaults)
очень хорошо подобраны, но время от времени они могут застать вас врасплох, особенно в начале.

Прежде всего: React Query _не_ вызывает _queryFn_ при каждом повторном рендеринге, даже если _staleTime_ по умолчанию равен нулю.
Ваше приложение может перерисовываться по разным причинам в любое время, поэтому отправлением запросов каждый такой раз было бы безумием!

Всегда кодируйте повторные рендеры, и их много. Мне нравится называть это устойчивостью рендеринга.
— Tanner Linsley

Если вы заметили что происходит refetch, которого вы не ожидали, скорее свего это из-за того
что вы сделали фокус на window, и React Query решил сделать _refetchOnWindowFocus_, метод,
который сам по себе отличная вещь в продакшене.

Если например пользователь переключит страницу в браузере, а потом снова вернется в ваше приложени,
фоновый refetch будет запущен автомаитчески и данные на экране будут обновлены если что-то
поменлляось в это время на сервере.

И все это будет происходить без спиннеров и подгрузок, а ваш компонент не перерендериться
если данные остались те м же что в вашем cache, так что можно не переживать.

Во время разработки, это будет срабатывать намного чаще, особенно когда вы например смотрите что-то в edvTools,
а потом снова что-то нажимаете или фокусироует окно приложения, оно снова попытается сделать refetch,
так чт будьте в курсе,

А также, я считаю было бы неплохо разьяснить разницу между _cacheTime_ и _staleTime_, потому что эти понятия
всплывают крайне часто, когда разговор идет о React Query

Stale Time: Продолжительность до перехода запроса из актуального в устаревший. Пока запрос на данные актуальный,
данные всегда будут читаться только из кэша, что не будет вызывать сетевой запрос, что отлично скажется
на оптимизации. Однако, если запрос устарел, вы все равно получите данные из кэша, но в это время
может начать происходит фоновый refetch, [при некоторых условиях](https://react-query.tanstack.com/docs/guides/caching).

Cache Time: Продолжительность, по истечении которой неактивные запросы будут удалены из кеша. По умолчанию это 5 минут.
Запросы переходят в неактивное состояние, как только не регистрируются слушатели,
а именно, когда все компоненты, использующие этот запрос, не участвут в рендере.

В основном, если вам необходимо поменять что-то в этих настройках, скорее всего вы будете менять именно Stale Time,
хоть опять же, всякое бывает, но мне никогда не надо было менять что-то в Cache Time

Есть отличная статья об этом в документации [Объяснение по примеру](https://react-query.tanstack.com/docs/guides/caching#a-detailed-caching-example)

### Использовани React Query DevTools

DevTools может помочь вам понять, в каком состоянии находится запрос.
DevTools также сообщит вам, какие данные в данный момент находятся в кеше, что упростит отладку.

В дополнение к этому я обнаружил, что это помогает ограничить ваше сетевое соединение в браузере DevTools.
если вы хотите лучше распознавать фоновые обновления, поскольку локальные сервера разработки обычно довольно быстры.

### Относись к запросу как с массиву зависимостей

Я имею ввиду массив зависимостей в
[useEffect](https://reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect) хуке,
с которым вы скорее всего

Почему эти двое похожи?

Потому что React Query будет запускать повторную загрузку всякий раз, когда изменяется ключ запроса, также
как и useEffect отработает в случае если хоть хоть како-то занчение из его массива зависисостей изменилось.

Поэтому, когда мы передаем переменную в нашу _queryFn_, мы почти всегда хотим получать данные при изменении этого значения.

Вместо того, чтобы организовывать сложные эффекты для ручного запуска повторного запроса, мы можем использовать ключ запроса:

```ts:title=feature/todos/queries.ts
type State = 'all' | 'open' | 'done'
type Todo = {
  id: number
  state: State
}
type Todos = ReadonlyArray<Todo>

const fetchTodos = async (state: State): Promise<Todos> => {
  const response = await axios.get(`todos/${state}`)
  return response.data
}

export const useTodosQuery = (state: State) =>
  useQuery(['todos', state], () => fetchTodos(state))
```

Здесь представьте, что наш пользовательский интерфейс отображает список задач вместе с параметром фильтра.
Нам необходим какой-то локальный стейт для того чтобы хранить эту филтрацию, и и как только пользователь
изменит свой выбор - мы обновим локальный стейт, и React Query автоматически запустит рефетч для нас,
потому что query key поменялся

Однако, мы все же сохраняем пользовательский вариант фильтрации В СИНХРОНИЗАЦИИ с нашей функцией запроса,
что очень похоже на работу useEffect и его массива зависимостей

Кстати, мне кажется я вообще ниокгда и не посылал перменную в _queryFn_ которая НЕ была бы частью queryKey.

#### Новая запись в кэше

Так как Query Key использован как ключ к Кэшу, мы получим новую запись в кэше, когда изменим фильтр,
с например "ALL" на "Done", и это вызовит состояние подргузки (возможно мы покажем спиннер) когда
пользователь поменяет значение первый раз

Это конечно же не идеально, так что нам остается использовать или _keepPreviousData_ опцию для таких случаев,
или, если это конечно возмжно, сделать предварительную запись в в только что созданном кэше с
[Первичные значения](https://react-query.tanstack.com/docs/guides/initial-query-data#initial-data-from-cache).

Пример выше идеальен для этого, потому что мы можем на стороне клиента сделать пре-филтеринг с нашим todos

```typescript
type State = 'all' | 'open' | 'done';
type Todo = {
  id: number;
  state: State;
};
type Todos = ReadonlyArray<Todo>;

const fetchTodos = async (state: State): Promise<Todos> => {
  const response = await axios.get(`todos/${state}`);
  return response.data;
};

export const useTodosQuery = (state: State) =>
  useQuery(['todos', state], () => fetchTodos(state), {
    initialData: () => {
      const allTodos = queryClient.getQueryData<Todos>(['todos', 'all']);
      const filteredData =
        allTodos?.filter((todo) => todo.state === state) ?? [];

      return filteredData.length > 0 ? filteredData : undefined;
    },
  });
```

Теперь, каждый раз когда пользователь переключается между состояниями, если у нас еще нет данных,
мы попытыаемся предзаписать ее с помощью нашего ALL TODOS кэша

Мы можем мгновенно показать DONE todos, которые у нас есть, и они все равно увидет обновленный список
когда фоновая подгрузка закончиться

Обратите внимание, что до v3 вам также нужно было установить свойство _initialStale_, чтобы фактически запускать фоновую подгрузку.

Я думаю это отличный вклад в UX, и всего в нескольько строк

### Храним серверное и клиентское состояние отдльно

Об этом хорошо сказано вот в этой вот статье - [putting-props-to-use-state](./putting-props-to-use-state),

Если вы получаете данные из _useQuery_, постарайтесь не помещать эти данные в локальное состояние.

Основная причина в том, что вы неявно отказываетесь от всех фоновых обновлений, которые React Query делает за вас,
потому что локальная копия состояния не будет обновляться.

Это нормально, если вы хотите, например. получить некоторые значения по умолчанию для формы,
и отрендерить ее, когда у вас есть данные.

Фоновые обновления вряд ли дадут что-то новое, даже если ваша форма уже инициализирована.
Поэтому, если вы делаете это намеренно, убедитесь, что _не_ отключены ненужные фоновые обновления, установив _staleTime_:

```javascript
const App = () => {
  const { data } = useQuery('key', queryFn, { staleTime: Infinity })

  return data ? <MyForm initialData={data} /> : null
}

const MyForm = ({ initialData} ) => {
  const [data, setData] = React.useState(initialData)
  ...
}
```

Эту концепцию будет немного сложнее реализовать, когда вы отображаете данные, которые вы также хотите разрешить пользователю редактировать, но у него много преимуществ.

Взгляните на несколько подготовленых примеров кода

<iframe
  src="https://codesandbox.io/embed/inspiring-mayer-rp3jx?fontsize=14&hidenavigation=1&theme=dark&view=preview"
  style="width:100%; height:600px; border:0; border-radius: 4px; overflow:hidden;"
  title="separate-server-and-client-state"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

Важной частью этой демонстрации является то, что мы никогда не помещаем значение, полученное из React Query, в локальное состояние.
Это гарантирует, что мы всегда видим самые свежие данные, потому что их локальная «копия» отсутствует.

### Опция "enabled"

Хук _useQuery_ имеет множество опций, которые вы можете использовать для настройки его поведения.
и опция _enabled_ одна из них. Она позовляет делать много крутых вещей.
Вот краткий список того, что мы смогли сделать благодаря этой опции:

- [Dependent Queries](https://react-query.tanstack.com/guides/dependent-queries)<br />
  Извлекать данные в одном запросе и запускать второй запрос только после того, как мы успешно получили данные из первого запроса.
- Включение и выключение запросов<br />
  У нас есть один запрос, который регулярно запрашивает данные благодаря _refetchInterval_, но мы можем временно приостановить его, если модальное открыто, чтобы избежать
  обновления в задней части экрана.
- Дождитесь ввода пользователя<br />
  Укажите некоторые критерии фильтрации в ключе запроса, но отключите их, пока пользователь не применит свои фильтры.
- Отключить запрос после некоторого пользовательского ввода<br/>
  если у нас есть draft значение, которое должно иметь приоритет над данными сервера. (смотрети пример выше)

### Не используйте queryCache как локальный менеджер состояний

Если вы вмешиваетесь в queryCache (_queryClient.setQueryData_), это должно быть только для оптимистичных обновлений.
или для записи данных, которые вы получаете от сервера после мутации.
Помните, что каждая фоновая загрузка может переопределить эти данные, поэтому

[Используйте](https://reactjs.org/docs/hooks-state.html)
[Что-то](https://zustand.surge.sh/)
[Другое](https://redux.js.org/)

для локального стейта.

### Создавайте свои хуки

Даже если это всего лишь обёртка одного вызова _useQuery_, создание пользовательского хука обычно окупается, потому что:

- Вы можете вытащить фактическую загрузку данных из пользовательского интерфейса, но позже совместить с вашим вызовом _useQuery_.

- Вы можете хранить все случаи использования одного ключа запроса (и, возможно, определения типов) в одном файле.

- Если вам нужно настроить некоторые параметры или добавить преобразование данных, вы можете сделать это в одном месте.

Вы уже видели пример этого в секции про массив зависимостей.

---

Спасибо за прочтение, так или иначе Я надеюсь, что эти практические советы помогут вам начать работу с React Query

Напомню, что эта статья является переводом статьи: https://tkdodo.eu/blog/practical-react-query
От: https://github.com/tkdodo
Перевел: https://github.com/garbalau-github

<Comments />
